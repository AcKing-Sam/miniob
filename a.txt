diff --git a/a.txt b/a.txt
new file mode 100644
index 0000000..e69de29
diff --git a/src/observer/sql/executor/execute_stage.cpp b/src/observer/sql/executor/execute_stage.cpp
index 4e61b02..e85f5d4 100644
--- a/src/observer/sql/executor/execute_stage.cpp
+++ b/src/observer/sql/executor/execute_stage.cpp
@@ -16,7 +16,6 @@ See the Mulan PSL v2 for more details. */
 #include <string>
 
 #include "sql/executor/execute_stage.h"
-
 #include "common/log/log.h"
 #include "event/session_event.h"
 #include "event/sql_event.h"
@@ -41,6 +40,7 @@ RC ExecuteStage::handle_request(SQLStageEvent *sql_event)
   SessionEvent *session_event = sql_event->session_event();
 
   Stmt *stmt = sql_event->stmt();
+
   if (stmt != nullptr) {
     CommandExecutor command_executor;
     rc = command_executor.execute(sql_event);
diff --git a/src/observer/sql/expr/aggregate_hash_table.cpp b/src/observer/sql/expr/aggregate_hash_table.cpp
index bc6f751..7659b60 100644
--- a/src/observer/sql/expr/aggregate_hash_table.cpp
+++ b/src/observer/sql/expr/aggregate_hash_table.cpp
@@ -262,7 +262,7 @@ void LinearProbingAggregateHashTable<V>::add_batch(int *input_keys, V *input_val
   memset(inv, -1, sizeof(inv)); // Initialize inv to -1
   memset(off, 0, sizeof(off));  // Initialize off to 0
 
-  std::cout << "cap " << capacity_ << std::endl;
+  // std::cout << "cap " << capacity_ << std::endl;
 
   int i = 0;
   __m256i keys = _mm256_setzero_si256();
@@ -273,7 +273,7 @@ void LinearProbingAggregateHashTable<V>::add_batch(int *input_keys, V *input_val
   while (i + SIMD_WIDTH <= len) {
       for (int j = 0; j < SIMD_WIDTH; ++j) {
           if (inv[j] == -1 && i < len) {
-              std::cout << "insert pos " << j << " key: " << input_keys[i] << std::endl;
+              // std::cout << "insert pos " << j << " key: " << input_keys[i] << std::endl;
               keys = insert_value(keys, input_keys[i], j);
               values = insert_value(values, input_values[i], j);
               inv[j] = 0;
@@ -287,7 +287,7 @@ void LinearProbingAggregateHashTable<V>::add_batch(int *input_keys, V *input_val
         if(inv[j] != -1) {
           int key = mm256_extract_epi32_var_indx(keys, j);
           int hash_val = hash_function(key + off[j]);
-          std::cout << "cal hash vals, pos: " << j << " key: " << key << " hash val: " << hash_val << std::endl;
+          // std::cout << "cal hash vals, pos: " << j << " key: " << key << " hash val: " << hash_val << std::endl;
           hash_vals = insert_value(hash_vals, hash_val, j);
         }
       }
diff --git a/src/observer/sql/expr/aggregator.cpp b/src/observer/sql/expr/aggregator.cpp
index 35d8573..1944bc5 100644
--- a/src/observer/sql/expr/aggregator.cpp
+++ b/src/observer/sql/expr/aggregator.cpp
@@ -45,3 +45,146 @@ RC SumAggregator::evaluate(Value& result)
   result = value_;
   return RC::SUCCESS;
 }
+
+RC MinAggregator::accumulate(const Value &value)
+{
+  if (value_.attr_type() == AttrType::UNDEFINED) {
+    value_ = value;
+    return RC::SUCCESS;
+  }
+  
+  ASSERT(value.attr_type() == value_.attr_type(), "type mismatch. value type: %s, value_.type: %s", 
+        attr_type_to_string(value.attr_type()), attr_type_to_string(value_.attr_type()));
+  
+  switch (value.attr_type())
+  {
+    case AttrType::INTS: {
+      value_.set_int(std::min(value.get_int(),value_.get_int()));
+    } break;
+    case AttrType::FLOATS: {
+      value_.set_float(std::min(value.get_float(),value_.get_float()));
+    } break;
+    case AttrType::CHARS: {
+      value_.set_string(std::min(value.get_string(), value_.get_string()).data());
+    } break;
+    case AttrType::DATES: {
+      value_.set_date(std::min(value.get_date(),value_.get_date()));
+    } break;
+    default: {
+      return RC::INTERNAL;
+    }
+  }
+  return RC::SUCCESS;
+}
+
+RC MinAggregator::evaluate(Value& result)
+{
+  result = value_;
+  return RC::SUCCESS;
+}
+
+RC MaxAggregator::accumulate(const Value &value)
+{
+  if (value_.attr_type() == AttrType::UNDEFINED) {
+    value_ = value;
+    return RC::SUCCESS;
+  }
+  
+  ASSERT(value.attr_type() == value_.attr_type(), "type mismatch. value type: %s, value_.type: %s", 
+        attr_type_to_string(value.attr_type()), attr_type_to_string(value_.attr_type()));
+  
+  switch (value.attr_type())
+  {
+    case AttrType::INTS: {
+      value_.set_int(std::max(value.get_int(),value_.get_int()));
+    } break;
+    case AttrType::FLOATS: {
+      value_.set_float(std::max(value.get_float(),value_.get_float()));
+    } break;
+    case AttrType::CHARS: {
+      value_.set_string(std::max(value.get_string(), value_.get_string()).data());
+    } break;
+    case AttrType::DATES: {
+      value_.set_date(std::max(value.get_date(),value_.get_date()));
+    } break;
+    default: {
+      return RC::INTERNAL;
+    }
+  }
+  return RC::SUCCESS;
+}
+
+RC MaxAggregator::evaluate(Value& result)
+{
+  result = value_;
+  return RC::SUCCESS;
+}
+
+RC AvgAggregator::accumulate(const Value &value)
+{
+  if (value_.attr_type() == AttrType::UNDEFINED) {
+    value_ = value;
+    return RC::SUCCESS;
+  }
+  
+  ASSERT(value.attr_type() == value_.attr_type(), "type mismatch. value type: %s, value_.type: %s", 
+        attr_type_to_string(value.attr_type()), attr_type_to_string(value_.attr_type()));
+  
+  switch (value.attr_type())
+  {
+    case AttrType::INTS: {
+      value_.set_int(value.get_int() + value_.get_int());
+    } break;
+    case AttrType::FLOATS: {
+      value_.set_float(value.get_float() + value_.get_float());
+    } break;
+    default: {
+      return RC::INTERNAL;
+    }
+  }
+  count_ ++;
+  return RC::SUCCESS;
+}
+
+RC AvgAggregator::evaluate(Value& result)
+{
+  switch (value_.attr_type())
+  {
+    case AttrType::INTS: {
+      int sum = value_.get_int();
+      if(sum % count_ == 0) {
+        result.set_int(value_.get_int() / count_);
+      } else {
+        result.set_type(AttrType::FLOATS);
+        result.set_float((float)value_.get_int() / count_);
+      }
+    } break;
+    case AttrType::FLOATS: {
+      result.set_float(value_.get_float() / count_);
+    } break;
+    default: {
+      return RC::INTERNAL;
+    }
+  }
+  return RC::SUCCESS;
+}
+
+RC CountAggregator::accumulate(const Value &value)
+{
+  if (value_.attr_type() == AttrType::UNDEFINED) {
+    value_ = value;
+    return RC::SUCCESS;
+  }
+  
+  ASSERT(value.attr_type() == value_.attr_type(), "type mismatch. value type: %s, value_.type: %s", 
+        attr_type_to_string(value.attr_type()), attr_type_to_string(value_.attr_type()));
+  
+  count_++;
+  return RC::SUCCESS;
+}
+
+RC CountAggregator::evaluate(Value& result)
+{
+  result.set_int(count_);
+  return RC::SUCCESS;
+}
diff --git a/src/observer/sql/expr/aggregator.h b/src/observer/sql/expr/aggregator.h
index 3b3ac74..c96dd20 100644
--- a/src/observer/sql/expr/aggregator.h
+++ b/src/observer/sql/expr/aggregator.h
@@ -34,4 +34,37 @@ class SumAggregator : public Aggregator
 public:
   RC accumulate(const Value &value) override;
   RC evaluate(Value &result) override;
+};
+
+class MinAggregator : public Aggregator
+{
+public:
+  RC accumulate(const Value &value) override;
+  RC evaluate(Value &result) override;
+};
+
+class MaxAggregator : public Aggregator
+{
+public:
+  RC accumulate(const Value &value) override;
+  RC evaluate(Value &result) override;
+};
+
+class AvgAggregator : public Aggregator
+{
+public:
+  RC accumulate(const Value &value) override;
+  RC evaluate(Value &result) override;
+
+private:
+  int count_ = 1;
+};
+
+class CountAggregator : public Aggregator
+{
+public:
+  RC accumulate(const Value &value) override;
+  RC evaluate(Value &result) override;
+private:
+  int count_ = 1;
 };
\ No newline at end of file
diff --git a/src/observer/sql/expr/expression.cpp b/src/observer/sql/expr/expression.cpp
index 0d5b453..52d5f2d 100644
--- a/src/observer/sql/expr/expression.cpp
+++ b/src/observer/sql/expr/expression.cpp
@@ -126,9 +126,31 @@ ComparisonExpr::ComparisonExpr(CompOp comp, unique_ptr<Expression> left, unique_
 
 ComparisonExpr::~ComparisonExpr() {}
 
+bool is_like(const char* text, const char* pattern) {
+    if (*pattern == '\0') {
+        return *text == '\0';
+    }
+    if (*pattern == '%') {
+        return is_like(text, pattern + 1) || (*text != '\0' && is_like(text + 1, pattern));
+    }
+    if (*pattern == '_' || *pattern == *text) {
+        return *text != '\0' && is_like(text + 1, pattern + 1);
+    }
+    return false;
+}
+
 RC ComparisonExpr::compare_value(const Value &left, const Value &right, bool &result) const
 {
   RC  rc         = RC::SUCCESS;
+
+  if(comp() == LIKE) {
+    result = is_like(left.data(), right.data()) || is_like(right.data(), left.data());
+    return rc;
+  } else if(comp() == NOT_LIKE) {
+    result = (!is_like(left.data(), right.data()) && !is_like(right.data(), left.data()));
+    return rc;
+  }
+
   int cmp_result = left.compare(right);
   result         = false;
   switch (comp_) {
@@ -592,6 +614,22 @@ unique_ptr<Aggregator> AggregateExpr::create_aggregator() const
       aggregator = make_unique<SumAggregator>();
       break;
     }
+    case Type::MIN: {
+      aggregator = make_unique<MinAggregator>();
+      break;
+    }
+    case Type::MAX: {
+      aggregator = make_unique<MaxAggregator>();
+      break;
+    }
+    case Type::AVG: {
+      aggregator = make_unique<AvgAggregator>();
+      break;
+    }
+    case Type::COUNT: {
+      aggregator = make_unique<CountAggregator>();
+      break;
+    }
     default: {
       ASSERT(false, "unsupported aggregate type");
       break;
diff --git a/src/observer/sql/operator/update_physical_operator.cpp b/src/observer/sql/operator/update_physical_operator.cpp
index de3971e..be2aa9a 100644
--- a/src/observer/sql/operator/update_physical_operator.cpp
+++ b/src/observer/sql/operator/update_physical_operator.cpp
@@ -48,7 +48,16 @@ RC UpdatePhysicalOperator::open(Trx *trx)
                 if(field->field().meta()->type() != value_->attr_type()) {
                   return RC::INVALID_ARGUMENT;
                 }
-                new_record.set_field(field->field().meta()->offset(), field->field().meta()->len(), (char *)value_->data());
+                if(value_->attr_type() == AttrType::CHARS) {
+                  if(value_->length() > field->field().meta()->len()) {
+                    return RC::INVALID_ARGUMENT;
+                  }
+                }
+                rc = new_record.set_field(field->field().meta()->offset(), field->field().meta()->len(), (char *)value_->data());
+                if (rc != RC::SUCCESS) {
+                  LOG_TRACE("set record failed=%s", strrc(rc));
+                  return rc;
+                }
                 break;
             }
         }
@@ -65,7 +74,7 @@ RC UpdatePhysicalOperator::open(Trx *trx)
   // 记录的有效性由事务来保证，如果事务不保证删除的有效性，那说明此事务类型不支持并发控制，比如 VacuousTrx
   for (int i = 0;i < records_.size();i ++) {
     auto& record = records_[i];
-    auto new_record = new_records_[i];
+    auto& new_record = new_records_[i];
     rc = trx_->update_record(table_, record, new_record);
     if (rc != RC::SUCCESS) {
       LOG_WARN("failed to update record: %s", strrc(rc));
diff --git a/src/observer/sql/parser/expression_binder.cpp b/src/observer/sql/parser/expression_binder.cpp
index 2daf85c..1253144 100644
--- a/src/observer/sql/parser/expression_binder.cpp
+++ b/src/observer/sql/parser/expression_binder.cpp
@@ -408,6 +408,8 @@ RC ExpressionBinder::bind_aggregate_expression(
     return RC::SUCCESS;
   }
 
+  bool found = false;
+
   auto unbound_aggregate_expr = static_cast<UnboundAggregateExpr *>(expr.get());
   const char *aggregate_name = unbound_aggregate_expr->aggregate_name();
   AggregateExpr::Type aggregate_type;
@@ -420,7 +422,22 @@ RC ExpressionBinder::bind_aggregate_expression(
   unique_ptr<Expression>        &child_expr = unbound_aggregate_expr->child();
   vector<unique_ptr<Expression>> child_bound_expressions;
 
+  // corner cases:
+  // 1. child_expr is nullptr, e.g., SUM() ...
+  if(child_expr == nullptr) {
+    return RC::INVALID_ARGUMENT;
+  }
+  // 2. SUM(*) ...
+  if (child_expr->type() == ExprType::STAR && aggregate_type != AggregateExpr::Type::COUNT) {
+    return RC::INVALID_ARGUMENT;
+  }   
+
+  if(child_expr->type() == ExprType::STAR) {
+    found = true;
+  }
+
   if (child_expr->type() == ExprType::STAR && aggregate_type == AggregateExpr::Type::COUNT) {
+    // change COUNT(*) to COUNT(1) ...
     ValueExpr *value_expr = new ValueExpr(Value(1));
     child_expr.reset(value_expr);
   } else {
@@ -429,6 +446,8 @@ RC ExpressionBinder::bind_aggregate_expression(
       return rc;
     }
 
+    // 3. ERROR WITH REDUNDANT COLUMNS
+    // fixed below...
     if (child_bound_expressions.size() != 1) {
       LOG_WARN("invalid children number of aggregate expression: %d", child_bound_expressions.size());
       return RC::INVALID_ARGUMENT;
@@ -438,14 +457,29 @@ RC ExpressionBinder::bind_aggregate_expression(
       child_expr.reset(child_bound_expressions[0].release());
     }
   }
+  // 4. ERROR WITH NON-EXISTENT COLUMNS
+  for(auto t : binder_context().query_tables()) {
+    for(auto fm : *t->table_meta().field_metas()) {
+      if(strcmp(fm.name(), child_expr->name()) == 0) {
+        found = true;
+        break;
+      }
+    }
+  }
+  if(!found) {
+    return RC::INVALID_ARGUMENT;
+  }
 
   auto aggregate_expr = make_unique<AggregateExpr>(aggregate_type, std::move(child_expr));
   aggregate_expr->set_name(unbound_aggregate_expr->name());
+    
   rc = check_aggregate_expression(*aggregate_expr);
   if (OB_FAIL(rc)) {
     return rc;
   }
 
   bound_expressions.emplace_back(std::move(aggregate_expr));
+
+  
   return RC::SUCCESS;
 }
diff --git a/src/observer/sql/parser/expression_binder.h b/src/observer/sql/parser/expression_binder.h
index d52f049..9e4a052 100644
--- a/src/observer/sql/parser/expression_binder.h
+++ b/src/observer/sql/parser/expression_binder.h
@@ -45,7 +45,7 @@ public:
   virtual ~ExpressionBinder() = default;
 
   RC bind_expression(std::unique_ptr<Expression> &expr, std::vector<std::unique_ptr<Expression>> &bound_expressions);
-
+  BinderContext& binder_context() { return context_; }
 private:
   RC bind_star_expression(
       std::unique_ptr<Expression> &star_expr, std::vector<std::unique_ptr<Expression>> &bound_expressions);
diff --git a/src/observer/sql/parser/lex_sql.cpp b/src/observer/sql/parser/lex_sql.cpp
index b2eb395..685bd7b 100644
Binary files a/src/observer/sql/parser/lex_sql.cpp and b/src/observer/sql/parser/lex_sql.cpp differ
diff --git a/src/observer/sql/parser/lex_sql.h b/src/observer/sql/parser/lex_sql.h
index b4fd123..b535f07 100644
--- a/src/observer/sql/parser/lex_sql.h
+++ b/src/observer/sql/parser/lex_sql.h
@@ -542,7 +542,7 @@ extern int yylex \
 #undef yyTABLES_NAME
 #endif
 
-#line 145 "lex_sql.l"
+#line 153 "lex_sql.l"
 
 
 #line 548 "lex_sql.h"
diff --git a/src/observer/sql/parser/lex_sql.l b/src/observer/sql/parser/lex_sql.l
index 0c51e3a..61f8689 100644
--- a/src/observer/sql/parser/lex_sql.l
+++ b/src/observer/sql/parser/lex_sql.l
@@ -84,6 +84,13 @@ QUOTE            [\'\"]
 
 ";"                                     RETURN_TOKEN(SEMICOLON);
 {DOT}                                   RETURN_TOKEN(DOT);
+SUM                                   RETURN_TOKEN(SUM_STR);
+MIN                                   RETURN_TOKEN(MIN_STR);
+MAX                                   RETURN_TOKEN(MAX_STR);
+AVG                                   RETURN_TOKEN(AVG_STR);
+COUNT                                 RETURN_TOKEN(COUNT_STR);
+LIKE                                    RETURN_TOKEN(LIKE_STR);
+"NOT LIKE"                              RETURN_TOKEN(NOT_LIKE_STR);
 EXIT                                    RETURN_TOKEN(EXIT);
 HELP                                    RETURN_TOKEN(HELP);
 DESC                                    RETURN_TOKEN(DESC);
@@ -134,6 +141,7 @@ FORMAT                                  RETURN_TOKEN(FORMAT);
 ">="                                    RETURN_TOKEN(GE);
 ">"                                     RETURN_TOKEN(GT);
 
+
 "+" |
 "-" |
 "*" |
diff --git a/src/observer/sql/parser/parse.cpp b/src/observer/sql/parser/parse.cpp
index 30b95e4..f3cc647 100644
--- a/src/observer/sql/parser/parse.cpp
+++ b/src/observer/sql/parser/parse.cpp
@@ -38,6 +38,7 @@ RC parse(const char *st, ParsedSqlResult *sql_result)
   parse_success_ = true;
   sql_parse(st, sql_result);
   if(!parse_success_) {
+    // std::cout << "syntax error" << std::endl;
     return RC::SQL_SYNTAX;
   }
   return RC::SUCCESS;
diff --git a/src/observer/sql/parser/parse_defs.h b/src/observer/sql/parser/parse_defs.h
index 4672bc1..41d596b 100644
--- a/src/observer/sql/parser/parse_defs.h
+++ b/src/observer/sql/parser/parse_defs.h
@@ -51,6 +51,8 @@ enum CompOp
   LESS_THAN,    ///< "<"
   GREAT_EQUAL,  ///< ">="
   GREAT_THAN,   ///< ">"
+  LIKE,         ///< LIKE
+  NOT_LIKE,     ///< NOT LIKE
   NO_OP
 };
 
diff --git a/src/observer/sql/parser/yacc_sql.cpp b/src/observer/sql/parser/yacc_sql.cpp
index 9a225f3..593ad3b 100644
Binary files a/src/observer/sql/parser/yacc_sql.cpp and b/src/observer/sql/parser/yacc_sql.cpp differ
diff --git a/src/observer/sql/parser/yacc_sql.hpp b/src/observer/sql/parser/yacc_sql.hpp
index 9df926c..5ff49c8 100644
--- a/src/observer/sql/parser/yacc_sql.hpp
+++ b/src/observer/sql/parser/yacc_sql.hpp
@@ -82,32 +82,39 @@ extern int yydebug;
     DATE_T = 283,                  /* DATE_T  */
     HELP = 284,                    /* HELP  */
     EXIT = 285,                    /* EXIT  */
-    DOT = 286,                     /* DOT  */
-    INTO = 287,                    /* INTO  */
-    VALUES = 288,                  /* VALUES  */
-    FROM = 289,                    /* FROM  */
-    WHERE = 290,                   /* WHERE  */
-    AND = 291,                     /* AND  */
-    SET = 292,                     /* SET  */
-    ON = 293,                      /* ON  */
-    LOAD = 294,                    /* LOAD  */
-    DATA = 295,                    /* DATA  */
-    INFILE = 296,                  /* INFILE  */
-    EXPLAIN = 297,                 /* EXPLAIN  */
-    STORAGE = 298,                 /* STORAGE  */
-    FORMAT = 299,                  /* FORMAT  */
-    EQ = 300,                      /* EQ  */
-    LT = 301,                      /* LT  */
-    GT = 302,                      /* GT  */
-    LE = 303,                      /* LE  */
-    GE = 304,                      /* GE  */
-    NE = 305,                      /* NE  */
-    NUMBER = 306,                  /* NUMBER  */
-    FLOAT = 307,                   /* FLOAT  */
-    DATE_STR = 308,                /* DATE_STR  */
-    ID = 309,                      /* ID  */
-    SSS = 310,                     /* SSS  */
-    UMINUS = 311                   /* UMINUS  */
+    SUM_STR = 286,                 /* SUM_STR  */
+    MIN_STR = 287,                 /* MIN_STR  */
+    MAX_STR = 288,                 /* MAX_STR  */
+    AVG_STR = 289,                 /* AVG_STR  */
+    COUNT_STR = 290,               /* COUNT_STR  */
+    LIKE_STR = 291,                /* LIKE_STR  */
+    NOT_LIKE_STR = 292,            /* NOT_LIKE_STR  */
+    DOT = 293,                     /* DOT  */
+    INTO = 294,                    /* INTO  */
+    VALUES = 295,                  /* VALUES  */
+    FROM = 296,                    /* FROM  */
+    WHERE = 297,                   /* WHERE  */
+    AND = 298,                     /* AND  */
+    SET = 299,                     /* SET  */
+    ON = 300,                      /* ON  */
+    LOAD = 301,                    /* LOAD  */
+    DATA = 302,                    /* DATA  */
+    INFILE = 303,                  /* INFILE  */
+    EXPLAIN = 304,                 /* EXPLAIN  */
+    STORAGE = 305,                 /* STORAGE  */
+    FORMAT = 306,                  /* FORMAT  */
+    EQ = 307,                      /* EQ  */
+    LT = 308,                      /* LT  */
+    GT = 309,                      /* GT  */
+    LE = 310,                      /* LE  */
+    GE = 311,                      /* GE  */
+    NE = 312,                      /* NE  */
+    NUMBER = 313,                  /* NUMBER  */
+    FLOAT = 314,                   /* FLOAT  */
+    DATE_STR = 315,                /* DATE_STR  */
+    ID = 316,                      /* ID  */
+    SSS = 317,                     /* SSS  */
+    UMINUS = 318                   /* UMINUS  */
   };
   typedef enum yytokentype yytoken_kind_t;
 #endif
@@ -116,7 +123,7 @@ extern int yydebug;
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 union YYSTYPE
 {
-#line 146 "yacc_sql.y"
+#line 151 "yacc_sql.y"
 
   ParsedSqlNode *                            sql_node;
   ConditionSqlNode *                         condition;
@@ -134,8 +141,9 @@ union YYSTYPE
   char *                                     string;
   int                                        number;
   float                                      floats;
+  char*                                      agg_func;
 
-#line 139 "yacc_sql.hpp"
+#line 147 "yacc_sql.hpp"
 
 };
 typedef union YYSTYPE YYSTYPE;
diff --git a/src/observer/sql/parser/yacc_sql.y b/src/observer/sql/parser/yacc_sql.y
index 2bce70c..3cdc934 100644
--- a/src/observer/sql/parser/yacc_sql.y
+++ b/src/observer/sql/parser/yacc_sql.y
@@ -38,12 +38,10 @@ bool check_date(int y, int m, int d) {
 bool init_date_value(Value* value, const char* v) {
     int y, m, d;
     sscanf(v, "%d-%d-%d", &y, &m, &d);
-    // std::cout << "666 " << y << " " << m << " " << d << std::endl;
     bool b = check_date(y, m, d);
     if(!b) {
       return false;
     }
-    // std::cout << "888 " << y << " " << m << " " << d << std::endl;
     int tmp = y * 10000 + m * 100 + d;
     value->set_date(tmp);
     return true;
@@ -121,6 +119,13 @@ UnboundAggregateExpr *create_aggregate_expression(const char *aggregate_name,
         DATE_T
         HELP
         EXIT
+        SUM_STR
+        MIN_STR
+        MAX_STR
+        AVG_STR
+        COUNT_STR
+        LIKE_STR
+        NOT_LIKE_STR
         DOT //QUOTE
         INTO
         VALUES
@@ -160,6 +165,7 @@ UnboundAggregateExpr *create_aggregate_expression(const char *aggregate_name,
   char *                                     string;
   int                                        number;
   float                                      floats;
+  char*                                      agg_func;
 }
 
 %token <number> NUMBER
@@ -170,6 +176,7 @@ UnboundAggregateExpr *create_aggregate_expression(const char *aggregate_name,
 //非终结符
 
 /** type 定义了各种解析后的结果输出的是什么类型。类型对应了 union 中的定义的成员变量名称 **/
+%type <agg_func>            agg_func
 %type <number>              type
 %type <condition>           condition
 %type <value>               value
@@ -440,7 +447,6 @@ value:
       if(!init_date_value(val, tmp)) {
         parse_success_ = false;
       }
-      
       $$ = val;
       free(tmp);
       free($1);
@@ -488,6 +494,7 @@ update_stmt:      /*  update 语句的语法解析树*/
       }
       free($2);
       free($4);
+      delete($6);
     }
     ;
 select_stmt:        /*  select 语句的语法解析树*/
@@ -575,10 +582,43 @@ expression:
     | '*' {
       $$ = new StarExpr();
     }
-    | ID LBRACE expression RBRACE {
+    | agg_func LBRACE expression RBRACE {
       $$ = create_aggregate_expression($1, $3, sql_string, &@$);
       free($1);
     }
+    | agg_func LBRACE RBRACE {
+      $$ = create_aggregate_expression($1, nullptr, sql_string, &@$);
+      parse_success_ = false;
+      free($1);
+    }
+    | agg_func LBRACE expression COMMA expression_list RBRACE {
+      $$ = create_aggregate_expression($1, $3, sql_string, &@$);
+      parse_success_ = false;
+      free($1);
+    }
+    ;
+
+agg_func:
+    SUM_STR { 
+      $$ = new char[4];
+      strcpy($$, "SUM");
+    }
+    | MIN_STR { 
+      $$ = new char[4];
+      strcpy($$, "MIN");
+    }
+    | MAX_STR { 
+      $$ = new char[4];
+      strcpy($$, "MAX");
+    }
+    | AVG_STR { 
+      $$ = new char[4];
+      strcpy($$, "AVG");
+    }
+    | COUNT_STR { 
+      $$ = new char[6];
+      strcpy($$, "COUNT");
+    }
     ;
 
 rel_attr:
@@ -702,6 +742,8 @@ comp_op:
     | LE { $$ = LESS_EQUAL; }
     | GE { $$ = GREAT_EQUAL; }
     | NE { $$ = NOT_EQUAL; }
+    | LIKE_STR { $$ = LIKE; }
+    | NOT_LIKE_STR { $$ = NOT_LIKE; }
     ;
 
 // your code here
diff --git a/src/observer/sql/stmt/filter_stmt.cpp b/src/observer/sql/stmt/filter_stmt.cpp
index 7cee72e..3b4f0e8 100644
--- a/src/observer/sql/stmt/filter_stmt.cpp
+++ b/src/observer/sql/stmt/filter_stmt.cpp
@@ -37,7 +37,6 @@ RC FilterStmt::create(Db *db, Table *default_table, std::unordered_map<std::stri
   for (int i = 0; i < condition_num; i++) {
     FilterUnit *filter_unit = nullptr;
     rc = create_filter_unit(db, default_table, tables, conditions[i], filter_unit);
-    
     if (rc != RC::SUCCESS) {
       delete tmp_stmt;
       LOG_WARN("failed to create filter unit. condition index=%d", i);
@@ -131,12 +130,19 @@ RC FilterStmt::create_filter_unit(Db *db, Table *default_table, std::unordered_m
 
   filter_unit->set_comp(comp);
 
-  // 检查两个类型是否能够比较
-  // need to judge date type here
-  // for example, WHERE c1='2000-12-07', c1(date type)
+  // check compare is valid here
   if(lt == AttrType::DATES && rt == AttrType::CHARS) {
     return RC::INVALID_ARGUMENT;
   }
+  // here, not support "col LIKE col" and "chars LIKE chars".
+  if(condition.comp == LIKE || condition.comp == NOT_LIKE) {
+    if(!condition.right_is_attr && !condition.left_is_attr) {
+      return RC::INVALID_ARGUMENT;
+    }
+    if(condition.right_is_attr && condition.left_is_attr) {
+      return RC::INVALID_ARGUMENT;
+    }
+  }
 
   return rc;
 }
diff --git a/src/observer/sql/stmt/select_stmt.cpp b/src/observer/sql/stmt/select_stmt.cpp
index 3a6b0d5..a51d9e7 100644
--- a/src/observer/sql/stmt/select_stmt.cpp
+++ b/src/observer/sql/stmt/select_stmt.cpp
@@ -100,8 +100,6 @@ RC SelectStmt::create(Db *db, SelectSqlNode &select_sql, Stmt *&stmt)
     return rc;
   }
 
-  std::cout << "select's filter stmt" << std::endl;
-
   // everything alright
   SelectStmt *select_stmt = new SelectStmt();
 
diff --git a/src/observer/sql/stmt/update_stmt.cpp b/src/observer/sql/stmt/update_stmt.cpp
index ca2a357..bd661a2 100644
--- a/src/observer/sql/stmt/update_stmt.cpp
+++ b/src/observer/sql/stmt/update_stmt.cpp
@@ -48,6 +48,19 @@ RC UpdateStmt::create(Db *db, const UpdateSqlNode &update_sql, Stmt *&stmt)
     return RC::SCHEMA_TABLE_NOT_EXIST;
   }
 
+  bool found_column = false;
+  // check whether the column exists
+  auto field_metas = *table->table_meta().field_metas();
+  for(auto mt : field_metas) {
+    if(mt.name() == update_sql.attribute_name) {
+      found_column = true;
+      break;
+    }
+  }
+  if(!found_column) {
+    return RC::INVALID_ARGUMENT;
+  }
+
   std::unordered_map<std::string, Table *> table_map;
   table_map.insert(std::pair<std::string, Table *>(std::string(table_name), table));
 




